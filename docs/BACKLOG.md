# Бэклог Проекта: Audio Event Annotation Tool

**Дата создания**: 2025-11-10

---

## Epic 1: Инфраструктура и Настройка Проекта

### Issue #1: Настройка базовой структуры Flask-приложения
**Labels**: `epic`, `setup`, `priority:high`

**Описание**:
Создать базовую структуру Flask-приложения с необходимыми конфигурационными файлами и точкой входа.

**Критерии Приемки**:
- [ ] Создан файл `run.py` с точкой входа приложения
- [ ] Создана директория `app/` с `__init__.py` и инициализацией Flask
- [ ] Создан `config.py` с классами конфигурации (Development, Production, Testing)
- [ ] Создан `requirements.txt` с базовыми зависимостями:
  - Flask>=3.0.0
  - SQLAlchemy>=2.0.0
  - Flask-SQLAlchemy
  - librosa>=0.10.0
  - soundfile>=0.12.0
  - numpy
  - scipy
- [ ] Приложение запускается без ошибок
- [ ] Добавлен `.gitignore` для Python-проектов

**Технические Детали**:
- Использовать Application Factory Pattern для Flask
- Настроить CORS для локальной разработки
- Максимальный размер каждого файла: 400 строк

---

### Issue #2: Настройка pytest и структуры тестирования
**Labels**: `setup`, `testing`, `priority:high`

**Описание**:
Настроить pytest и behave для unit и BDD тестирования.

**Критерии Приемки**:
- [ ] Создана директория `tests/` с `__init__.py`
- [ ] Создана поддиректория `tests/unit/`
- [ ] Создана поддиректория `tests/features/` для BDD тестов
- [ ] Добавлен `pytest.ini` или `pyproject.toml` с настройками pytest
- [ ] Добавлены зависимости в `requirements.txt`:
  - pytest>=7.0.0
  - pytest-cov
  - behave>=1.2.6
- [ ] Создан базовый тест для проверки импорта приложения
- [ ] Команда `pytest` выполняется успешно

---

## Epic 2: Модели Данных и База Данных

### Issue #3: Создание SQLAlchemy моделей для сущностей
**Labels**: `epic`, `backend`, `database`, `priority:high`

**Описание**:
Создать модели данных для Project, AudioFile, EventType, Annotation согласно спецификации в PROJECT_CONTEXT.md.

**Критерии Приемки**:
- [ ] Создан файл `app/models.py` с моделями:
  - Project
  - AudioFile
  - EventType
  - Annotation
- [ ] Все поля соответствуют спецификации в PROJECT_CONTEXT.md
- [ ] Определены связи между моделями (Foreign Keys)
- [ ] Добавлены индексы для часто запрашиваемых полей
- [ ] Написаны unit-тесты для моделей
- [ ] Размер файла не превышает 400 строк (если превышает - разбить на модули)

**Технические Детали**:
```python
# Примерная структура связей:
Project -> 1:N -> AudioFile
AudioFile -> 1:N -> Annotation
EventType -> 1:N -> Annotation
```

---

### Issue #4: Настройка SQLite базы данных и миграций
**Labels**: `backend`, `database`, `priority:high`

**Описание**:
Настроить SQLite базу данных и систему миграций с использованием Flask-Migrate (Alembic).

**Критерии Приемки**:
- [ ] Добавлена зависимость Flask-Migrate в `requirements.txt`
- [ ] Создана директория `migrations/`
- [ ] База данных создается автоматически при первом запуске
- [ ] Файл БД (`app.db`) добавлен в `.gitignore`
- [ ] Созданы начальные миграции для всех моделей
- [ ] Команды `flask db init`, `flask db migrate`, `flask db upgrade` работают корректно
- [ ] Написаны тесты для проверки создания таблиц

---

### Issue #5: Создание базовых CRUD операций для моделей
**Labels**: `backend`, `database`, `priority:medium`

**Описание**:
Реализовать базовые операции Create, Read, Update, Delete для всех моделей в виде сервисных функций.

**Критерии Приемки**:
- [ ] Создан файл `app/services/crud.py` с функциями CRUD
- [ ] Реализованы функции для каждой модели:
  - `create_X()`, `get_X_by_id()`, `get_all_X()`, `update_X()`, `delete_X()`
- [ ] Все функции обрабатывают ошибки (try-except)
- [ ] Написаны unit-тесты для каждой функции
- [ ] Тесты используют временную in-memory БД
- [ ] Размер файла не превышает 400 строк

---

## Epic 3: Работа с Аудиофайлами

### Issue #6: Создание сервиса для сканирования аудиофайлов
**Labels**: `epic`, `backend`, `audio`, `priority:high`

**Описание**:
Реализовать сервис для рекурсивного сканирования директории и извлечения метаданных аудиофайлов.

**Критерии Приемки**:
- [ ] Создан файл `app/services/file_scanner.py`
- [ ] Реализована функция `scan_directory(root_path, recursive=True)`
- [ ] Функция находит файлы форматов: .wav, .mp3, .flac, .ogg
- [ ] Извлекаются метаданные: duration, sample_rate, channels, file_size
- [ ] Используется soundfile для WAV/FLAC, librosa для MP3/OGG
- [ ] Обрабатываются ошибки (поврежденные файлы пропускаются с логированием)
- [ ] Написаны unit-тесты с тестовыми аудиофайлами
- [ ] Размер файла не превышает 300 строк

**Технические Детали**:
- Использовать `os.walk()` для рекурсивного обхода
- Проверять файлы через `soundfile.info()` (быстрее чем полная загрузка)

---

### Issue #7: API эндпоинт для создания проекта и индексации файлов
**Labels**: `backend`, `api`, `priority:high`

**Описание**:
Создать REST API эндпоинты для управления проектами и индексации аудиофайлов.

**Критерии Приемки**:
- [ ] Создан файл `app/routes/projects.py`
- [ ] Реализованы эндпоинты:
  - `POST /api/projects` - создание проекта
  - `GET /api/projects` - список всех проектов
  - `GET /api/projects/<id>` - получение проекта по ID
  - `POST /api/projects/<id>/scan` - сканирование и индексация файлов
  - `GET /api/projects/<id>/files` - список файлов в проекте
- [ ] Все эндпоинты возвращают JSON
- [ ] Добавлена валидация входных данных
- [ ] Обработка ошибок (400, 404, 500)
- [ ] Написаны BDD тесты (behave) для каждого эндпоинта
- [ ] Размер файла не превышает 400 строк

**Формат ответа для POST /api/projects/<id>/scan**:
```json
{
  "status": "success",
  "files_found": 15,
  "files_indexed": 14,
  "errors": 1,
  "duration_sec": 2.5
}
```

---

### Issue #8: Создание сервиса для потоковой загрузки аудио
**Labels**: `backend`, `audio`, `priority:high`

**Описание**:
Реализовать сервис для эффективной потоковой загрузки больших аудиофайлов с поддержкой Range requests.

**Критерии Приемки**:
- [ ] Создан файл `app/services/audio_processor.py`
- [ ] Реализована функция `load_audio_chunk(file_path, start_sec, end_sec)`
- [ ] Функция загружает только указанный временной фрагмент
- [ ] Поддержка всех форматов (WAV, MP3, FLAC, OGG)
- [ ] Оптимизация памяти: не загружать весь файл
- [ ] Обработка ошибок (файл не найден, поврежден)
- [ ] Написаны unit-тесты с тестовыми файлами разных форматов
- [ ] Размер файла не превышает 300 строк

**Технические Детали**:
- Использовать `soundfile.read()` с параметрами `start` и `stop`
- Для MP3 может потребоваться librosa

---

### Issue #9: API эндпоинт для стриминга аудио
**Labels**: `backend`, `api`, `audio`, `priority:high`

**Описание**:
Создать эндпоинт для потоковой передачи аудиофрагментов клиенту.

**Критерии Приемки**:
- [ ] Создан файл `app/routes/audio.py`
- [ ] Реализован эндпоинт:
  - `GET /api/audio/<file_id>/stream?start=0&end=10` - получение фрагмента
- [ ] Эндпоинт возвращает аудио в формате WAV (PCM)
- [ ] Добавлены HTTP заголовки для аудио (Content-Type, Content-Length)
- [ ] Поддержка HTTP Range requests (опционально для MVP)
- [ ] Обработка ошибок (файл не найден, неверные параметры)
- [ ] Написаны integration тесты
- [ ] Размер файла не превышает 200 строк

---

## Epic 4: API для Визуализации

### Issue #10: Генерация waveform данных для аудиофайла
**Labels**: `epic`, `backend`, `audio`, `visualization`, `priority:high`

**Описание**:
Реализовать функцию для генерации downsampled waveform данных для эффективной визуализации.

**Критерии Приемки**:
- [ ] Добавлена функция в `app/services/audio_processor.py`:
  - `generate_waveform(file_path, start_sec, end_sec, width_pixels=1000)`
- [ ] Функция возвращает массив min/max значений для каждого пикселя
- [ ] Поддержка стерео: возврат данных для каждого канала
- [ ] Оптимизация: обработка больших файлов без полной загрузки в память
- [ ] Нормализация значений (-1.0 до 1.0)
- [ ] Написаны unit-тесты
- [ ] Размер добавленного кода не превышает 150 строк

**Формат ответа**:
```json
{
  "channels": 2,
  "data": [
    [{"min": -0.5, "max": 0.7}, ...],  // channel 0
    [{"min": -0.3, "max": 0.4}, ...]   // channel 1
  ],
  "sample_rate": 44100
}
```

---

### Issue #11: API эндпоинт для получения waveform
**Labels**: `backend`, `api`, `visualization`, `priority:high`

**Описание**:
Создать эндпоинт для получения waveform данных.

**Критерии Приемки**:
- [ ] Реализован эндпоинт в `app/routes/audio.py`:
  - `GET /api/audio/<file_id>/waveform?start=0&end=10&width=1000`
- [ ] Эндпоинт возвращает JSON с waveform данными
- [ ] Параметр `width` определяет количество точек данных
- [ ] Добавлено кэширование результатов (опционально)
- [ ] Обработка ошибок
- [ ] Написаны integration тесты
- [ ] Размер добавленного кода не превышает 100 строк

---

### Issue #12: Генерация спектрограммы для аудиофрагмента
**Labels**: `backend`, `audio`, `visualization`, `priority:medium`

**Описание**:
Реализовать функцию для генерации спектрограммы (STFT) аудиофрагмента.

**Критерии Приемки**:
- [ ] Добавлена функция в `app/services/audio_processor.py`:
  - `generate_spectrogram(file_path, start_sec, end_sec, n_fft=2048, hop_length=512)`
- [ ] Функция возвращает mel-спектрограмму или STFT
- [ ] Данные конвертируются в dB шкалу
- [ ] Поддержка стерео (обработка первого канала или микс)
- [ ] Возврат данных в формате, удобном для визуализации (2D массив)
- [ ] Написаны unit-тесты
- [ ] Размер добавленного кода не превышает 200 строк

**Технические Детали**:
- Использовать `librosa.stft()` или `librosa.feature.melspectrogram()`
- Конвертация в dB: `librosa.power_to_db()`

---

### Issue #13: API эндпоинт для получения спектрограммы
**Labels**: `backend`, `api`, `visualization`, `priority:medium`

**Описание**:
Создать эндпоинт для получения спектрограммы.

**Критерии Приемки**:
- [ ] Реализован эндпоинт в `app/routes/audio.py`:
  - `GET /api/audio/<file_id>/spectrogram?start=0&end=10&width=1000&height=256`
- [ ] Эндпоинт возвращает JSON с данными спектрограммы
- [ ] Параметры `width` и `height` определяют размер изображения
- [ ] Возврат метаданных (частотный диапазон, временное разрешение)
- [ ] Обработка ошибок
- [ ] Написаны integration тесты
- [ ] Размер добавленного кода не превышает 150 строк

---

## Epic 5: Фронтенд - Базовый Интерфейс

### Issue #14: Создание HTML структуры главной страницы
**Labels**: `epic`, `frontend`, `ui`, `priority:high`

**Описание**:
Создать базовую HTML структуру приложения с разделением на панели.

**Критерии Приемки**:
- [ ] Создан файл `static/index.html`
- [ ] Структура включает:
  - Заголовок приложения
  - Панель выбора проекта/файла (sidebar)
  - Основную панель визуализации
  - Панель управления (воспроизведение, зум)
  - Панель аннотаций (список)
- [ ] Использован семантический HTML5
- [ ] Добавлены базовые meta-теги
- [ ] Подключен CSS файл
- [ ] Подключены JS модули
- [ ] Размер файла не превышает 300 строк

---

### Issue #15: Создание CSS стилей для интерфейса
**Labels**: `frontend`, `ui`, `priority:medium`

**Описание**:
Разработать современные CSS стили для интерфейса приложения.

**Критерии Приемки**:
- [ ] Создан файл `static/css/styles.css`
- [ ] Реализована responsive верстка (flexbox/grid)
- [ ] Цветовая схема: темная тема для работы с аудио
- [ ] Стилизованы все UI элементы (кнопки, инпуты, списки)
- [ ] Hover и active состояния для интерактивных элементов
- [ ] Анимации для улучшения UX (плавные переходы)
- [ ] Размер файла не превышает 400 строк

**Дизайн Требования**:
- Цвета: темный фон (#1e1e1e), светлый текст (#e0e0e0)
- Акцентный цвет для выделений и кнопок (#4a90e2)
- Монохромные тона для waveform

---

### Issue #16: JavaScript модуль для работы с API
**Labels**: `frontend`, `javascript`, `priority:high`

**Описание**:
Создать JavaScript модуль для взаимодействия с backend API.

**Критерии Приемки**:
- [ ] Создан файл `static/js/api.js`
- [ ] Реализованы функции для всех API эндпоинтов:
  - Projects: create, list, get, scan
  - Audio: stream, waveform, spectrogram
  - Annotations: create, list, update, delete (будет добавлено позже)
- [ ] Использован Fetch API с async/await
- [ ] Обработка ошибок и отображение пользователю
- [ ] Добавлены JSDoc комментарии
- [ ] Размер файла не превышает 300 строк

---

### Issue #17: JavaScript модуль для визуализации waveform
**Labels**: `frontend`, `javascript`, `visualization`, `priority:high`

**Описание**:
Создать модуль для отрисовки waveform на HTML5 Canvas.

**Критерии Приемки**:
- [ ] Создан файл `static/js/visualizer.js`
- [ ] Реализован класс `WaveformVisualizer`
- [ ] Метод `drawWaveform(canvasId, waveformData)` отрисовывает waveform
- [ ] Поддержка стерео (два канала на одном canvas)
- [ ] Отрисовка min/max огибающих
- [ ] Плавная прокрутка и зум
- [ ] Отображение временных меток
- [ ] Размер файла не превышает 350 строк

**Технические Детали**:
- Использовать `requestAnimationFrame` для плавной отрисовки
- Оптимизация: перерисовка только при изменениях

---

### Issue #18: JavaScript модуль для визуализации спектрограммы
**Labels**: `frontend`, `javascript`, `visualization`, `priority:medium`

**Описание**:
Создать модуль для отрисовки спектрограммы на HTML5 Canvas.

**Критерии Приемки**:
- [ ] Добавлен класс `SpectrogramVisualizer` в `static/js/visualizer.js`
- [ ] Метод `drawSpectrogram(canvasId, spectrogramData)` отрисовывает спектрограмму
- [ ] Использование цветовой карты (viridis или jet)
- [ ] Отображение частотной оси (Hz)
- [ ] Отображение временной оси
- [ ] Интерполяция для сглаживания
- [ ] Размер добавленного кода не превышает 250 строк

---

### Issue #19: JavaScript модуль для аудио плеера
**Labels**: `frontend`, `javascript`, `audio`, `priority:high`

**Описание**:
Создать модуль для воспроизведения аудио с использованием Web Audio API.

**Критерии Приемки**:
- [ ] Создан файл `static/js/audio_player.js`
- [ ] Реализован класс `AudioPlayer`
- [ ] Методы: `play()`, `pause()`, `stop()`, `seek(time)`
- [ ] Воспроизведение фрагмента из API stream endpoint
- [ ] Синхронизация плейбека с визуализацией (курсор воспроизведения)
- [ ] Обработка ошибок загрузки
- [ ] Размер файла не превышает 250 строк

---

### Issue #20: Интеграция модулей и базовый workflow
**Labels**: `frontend`, `integration`, `priority:high`

**Описание**:
Интегрировать все фронтенд модули и реализовать базовый пользовательский workflow.

**Критерии Приемки**:
- [ ] Создан главный файл `static/js/app.js`
- [ ] Реализован workflow:
  1. Выбор/создание проекта
  2. Сканирование директории
  3. Выбор аудиофайла из списка
  4. Загрузка и отображение waveform
  5. Загрузка и отображение спектрограммы
  6. Воспроизведение аудио
- [ ] Все модули взаимодействуют корректно
- [ ] Обработка loading состояний (спиннеры)
- [ ] Обработка ошибок с отображением пользователю
- [ ] Размер файла не превышает 350 строк

---

## Epic 6: Аннотирование

### Issue #21: Реализация выделения временного участка на waveform
**Labels**: `epic`, `frontend`, `javascript`, `interaction`, `priority:high`

**Описание**:
Добавить возможность выделения временного участка мышью на waveform.

**Критерии Приемки**:
- [ ] Добавлен функционал в `WaveformVisualizer` класс
- [ ] Выделение участка: клик и drag мышью
- [ ] Визуальная индикация выделенной области (полупрозрачный прямоугольник)
- [ ] Отображение временных границ выделения
- [ ] Возможность изменения границ (drag за края)
- [ ] Событие `onSelectionChange` с параметрами start_time, end_time
- [ ] Размер добавленного кода не превышает 200 строк

---

### Issue #22: Воспроизведение выделенного фрагмента
**Labels**: `frontend`, `javascript`, `audio`, `priority:high`

**Описание**:
Добавить функционал воспроизведения только выделенного временного участка.

**Критерии Приемки**:
- [ ] Добавлен метод `playSelection(start, end)` в `AudioPlayer` класс
- [ ] Кнопка "Play Selection" в UI
- [ ] Воспроизведение останавливается автоматически в конце выделения
- [ ] Визуальная индикация воспроизведения (курсор движется)
- [ ] Обработка ошибок
- [ ] Размер добавленного кода не превышает 100 строк

---

### Issue #23: CRUD API для аннотаций
**Labels**: `backend`, `api`, `priority:high`

**Описание**:
Создать REST API эндпоинты для управления аннотациями.

**Критерии Приемки**:
- [ ] Создан файл `app/routes/annotations.py`
- [ ] Реализованы эндпоинты:
  - `POST /api/annotations` - создание аннотации
  - `GET /api/audio/<file_id>/annotations` - список аннотаций для файла
  - `GET /api/annotations/<id>` - получение аннотации
  - `PUT /api/annotations/<id>` - обновление аннотации
  - `DELETE /api/annotations/<id>` - удаление аннотации
- [ ] Валидация входных данных
- [ ] Обработка ошибок
- [ ] Написаны BDD тесты
- [ ] Размер файла не превышает 300 строк

**Формат POST запроса**:
```json
{
  "audio_file_id": 1,
  "start_time": 10.5,
  "end_time": 15.2,
  "event_type_id": 2,
  "label": "Speech",
  "confidence": 4,
  "notes": "Clear speech segment"
}
```

---

### Issue #24: UI форма для создания аннотации
**Labels**: `frontend`, `ui`, `priority:high`

**Описание**:
Создать модальное окно/форму для добавления аннотации к выделенному участку.

**Критерии Приемки**:
- [ ] Модальное окно открывается после выделения участка и нажатия "Add Annotation"
- [ ] Форма содержит поля:
  - Label (текстовое поле)
  - Event Type (выпадающий список)
  - Confidence (радио кнопки 1-5 или слайдер)
  - Notes (textarea)
  - Start/End time (только для чтения, но редактируемые)
- [ ] Кнопки: Save, Cancel
- [ ] Валидация на клиенте
- [ ] После сохранения - отправка POST запроса к API
- [ ] Размер добавленного кода не превышает 200 строк

---

### Issue #25: Отображение аннотаций на waveform
**Labels**: `frontend`, `javascript`, `visualization`, `priority:high`

**Описание**:
Добавить отображение сохраненных аннотаций поверх waveform.

**Критерии Приемки**:
- [ ] Аннотации загружаются при открытии файла
- [ ] Каждая аннотация отображается как цветной прямоугольник на временной шкале
- [ ] Цвет соответствует типу события
- [ ] При наведении - всплывающая подсказка с информацией (label, time range)
- [ ] Клик по аннотации - выделение и открытие формы редактирования
- [ ] Размер добавленного кода не превышает 150 строк

---

### Issue #26: Список аннотаций в боковой панели
**Labels**: `frontend`, `ui`, `priority:medium`

**Описание**:
Создать список всех аннотаций в боковой панели с возможностью фильтрации.

**Критерии Приемки**:
- [ ] Список отображает все аннотации для текущего файла
- [ ] Каждый элемент показывает: time range, label, event type
- [ ] Клик по элементу - переход к этому участку и выделение
- [ ] Кнопка удаления для каждой аннотации
- [ ] Фильтр по типу события
- [ ] Сортировка по времени
- [ ] Размер добавленного кода не превышает 250 строк

---

### Issue #27: CRUD API для типов событий
**Labels**: `backend`, `api`, `priority:medium`

**Описание**:
Создать REST API для управления типами событий.

**Критерии Приемки**:
- [ ] Добавлены эндпоинты в `app/routes/annotations.py` или новый файл
- [ ] Реализованы эндпоинты:
  - `POST /api/event-types` - создание типа
  - `GET /api/event-types` - список всех типов
  - `PUT /api/event-types/<id>` - обновление
  - `DELETE /api/event-types/<id>` - удаление (с проверкой использования)
- [ ] Валидация (уникальность имени, валидный hex цвет)
- [ ] Написаны тесты
- [ ] Размер добавленного кода не превышает 200 строк

---

### Issue #28: UI для управления типами событий
**Labels**: `frontend`, `ui`, `priority:medium`

**Описание**:
Создать интерфейс для создания и редактирования типов событий.

**Критерии Приемки**:
- [ ] Отдельная страница или секция в настройках
- [ ] Список существующих типов событий с цветами
- [ ] Форма добавления нового типа (название, описание, цвет)
- [ ] Color picker для выбора цвета
- [ ] Редактирование и удаление типов
- [ ] Предупреждение при удалении используемого типа
- [ ] Размер добавленного кода не превышает 250 строк

---

## Epic 7: Экспорт Данных

### Issue #29: Реализация экспорта в JSON формат
**Labels**: `epic`, `backend`, `export`, `priority:medium`

**Описание**:
Реализовать функцию для экспорта всех аннотаций проекта/файла в JSON формат.

**Критерии Приемки**:
- [ ] Создан файл `app/services/export.py`
- [ ] Реализована функция `export_to_json(audio_file_id)`
- [ ] JSON содержит:
  - Метаданные файла (path, duration, sample_rate)
  - Список аннотаций с полной информацией
  - Список использованных типов событий
  - Timestamp экспорта
- [ ] Валидный JSON формат
- [ ] Написаны unit-тесты
- [ ] Размер файла не превышает 200 строк

**Формат JSON**:
```json
{
  "exported_at": "2025-11-10T12:00:00Z",
  "audio_file": {
    "path": "/path/to/file.wav",
    "duration": 120.5,
    "sample_rate": 44100
  },
  "event_types": [...],
  "annotations": [...]
}
```

---

### Issue #30: Реализация экспорта в CSV формат
**Labels**: `backend`, `export`, `priority:medium`

**Описание**:
Реализовать функцию для экспорта аннотаций в CSV формат.

**Критерии Приемки**:
- [ ] Добавлена функция `export_to_csv(audio_file_id)` в `app/services/export.py`
- [ ] CSV содержит колонки:
  - start_time, end_time, duration, label, event_type, confidence, notes
- [ ] Первая строка - заголовки
- [ ] Используется стандартная библиотека `csv`
- [ ] Экранирование спецсимволов
- [ ] Написаны unit-тесты
- [ ] Размер добавленного кода не превышает 100 строк

---

### Issue #31: Реализация экспорта в Audacity Labels формат
**Labels**: `backend`, `export`, `priority:low`

**Описание**:
Реализовать функцию для экспорта аннотаций в формат Audacity Labels (.txt).

**Критерии Приемки**:
- [ ] Добавлена функция `export_to_audacity(audio_file_id)` в `app/services/export.py`
- [ ] Формат соответствует Audacity Labels: `start_time\tend_time\tlabel`
- [ ] Метка включает тип события и label
- [ ] Написаны unit-тесты
- [ ] Размер добавленного кода не превышает 80 строк

**Пример формата**:
```
10.500000	15.200000	Speech: Clear speech segment
20.100000	25.300000	Music: Background music
```

---

### Issue #32: API эндпоинты для экспорта
**Labels**: `backend`, `api`, `export`, `priority:medium`

**Описание**:
Создать API эндпоинты для скачивания экспортированных данных.

**Критерии Приемки**:
- [ ] Создан файл `app/routes/export.py` или добавлено в существующий
- [ ] Реализованы эндпоинты:
  - `GET /api/audio/<file_id>/export/json` - скачать JSON
  - `GET /api/audio/<file_id>/export/csv` - скачать CSV
  - `GET /api/audio/<file_id>/export/audacity` - скачать Audacity labels
- [ ] Правильные HTTP заголовки (Content-Type, Content-Disposition)
- [ ] Обработка ошибок
- [ ] Написаны integration тесты
- [ ] Размер файла не превышает 150 строк

---

### Issue #33: UI кнопки для экспорта данных
**Labels**: `frontend`, `ui`, `priority:medium`

**Описание**:
Добавить кнопки экспорта в интерфейс приложения.

**Критерии Приемки**:
- [ ] Секция "Export" в боковой панели или меню
- [ ] Три кнопки: "Export as JSON", "Export as CSV", "Export as Audacity Labels"
- [ ] Клик по кнопке - загрузка файла через браузер
- [ ] Использование API эндпоинтов экспорта
- [ ] Индикация процесса загрузки
- [ ] Обработка ошибок
- [ ] Размер добавленного кода не превышает 100 строк

---

## Дополнительные Задачи (Improvements)

### Issue #34: Добавление горячих клавиш
**Labels**: `enhancement`, `frontend`, `ux`, `priority:low`

**Описание**:
Реализовать горячие клавиши для ускорения работы.

**Критерии Приемки**:
- [ ] Space - play/pause
- [ ] Left/Right arrows - навигация на 1 секунду
- [ ] Shift + Left/Right - навигация на 10 секунд
- [ ] Enter - добавить аннотацию для выделения
- [ ] Delete - удалить выбранную аннотацию
- [ ] +/- - зум in/out
- [ ] Подсказка с горячими клавишами в UI

---

### Issue #35: Добавление функции отмены (Undo/Redo)
**Labels**: `enhancement`, `frontend`, `priority:low`

**Описание**:
Реализовать возможность отмены и повтора действий с аннотациями.

**Критерии Приемки**:
- [ ] История действий (create, update, delete аннотаций)
- [ ] Кнопки Undo/Redo в UI
- [ ] Горячие клавиши Ctrl+Z / Ctrl+Y
- [ ] Ограничение истории (последние 50 действий)

---

### Issue #36: Оптимизация производительности для очень больших файлов
**Labels**: `enhancement`, `backend`, `performance`, `priority:low`

**Описание**:
Оптимизировать обработку файлов размером > 5 ГБ.

**Критерии Приемки**:
- [ ] Lazy loading: загрузка только видимой части waveform
- [ ] Кэширование сгенерированных waveform/спектрограмм
- [ ] Progress bar для длительных операций
- [ ] Тестирование на файлах > 10 ГБ

---

### Issue #37: Документация пользователя
**Labels**: `documentation`, `priority:low`

**Описание**:
Создать руководство пользователя и документацию API.

**Критерии Приемки**:
- [ ] README.md с инструкциями по установке и запуску
- [ ] Руководство пользователя (docs/USER_GUIDE.md)
- [ ] API документация (Swagger/OpenAPI или вручную)
- [ ] Скриншоты интерфейса

---

## Приоритеты Реализации

**Фаза 1 (MVP Core)**:
- Issues #1-9: Инфраструктура, модели, работа с аудио

**Фаза 2 (Visualization)**:
- Issues #10-13: API для визуализации
- Issues #14-20: Базовый фронтенд

**Фаза 3 (Annotation)**:
- Issues #21-28: Функционал аннотирования

**Фаза 4 (Export & Polish)**:
- Issues #29-33: Экспорт данных
- Issues #34-37: Улучшения и документация

---

**Итого**: 37 задач разбитых на 7 эпиков
**Оценка времени**: 4-6 недель разработки (при работе одного разработчика)

